;; Heap
(import (yuni scheme)
        (yunivm heap fixnum allocator)
        (yunivm heap fixnum bits32)
        (yunivm heap fixnum bitvector))

(define test-counter 0)
(define success-counter 0)
(define failed-forms '())

(define (check-finish)
  (display "Test: ")
  (display success-counter)
  (display "/")
  (display test-counter)
  (display " passed.\n")
  (unless (null? failed-forms)
    (display "\nFailed: \n")
    (for-each (lambda x
                (display "    ")
                (write x)
                (display "\n")
                ;; YuniVM: result convertion workaround
                #t)
              (reverse failed-forms)))
  ;; FIXME: Restore this later
  ;(flush-output-port (current-output-port))
  (exit (if (null? failed-forms) 0 1)))

(define-syntax check-equal
  (syntax-rules ()
    ((_ obj form)
     (begin
       ;(display (list 'obj 'form)) (newline)
       (set! test-counter (+ 1 test-counter))
       (let ((e form))
        (cond ((equal? obj e)
               (set! success-counter (+ 1 success-counter)))
              (else
                (set! failed-forms (cons 'form failed-forms)))))))))


;; Rand
(define X32 (expt 2 32))
(define X13 (expt 2 13))
(define X17 (expt 2 17))
(define X5 (expt 2 5))
(define (round32 x) (modulo x X32))
(define (u<<13 x) (round32 (* x X13)))
(define (u>>17 x) (quotient x X17))
(define (u<<5 x) (round32 (* x X5)))
(define xortbl2x2
  '#(#(0 1 2 3) ;; 0
     #(1 0 3 2) ;; 1
     #(2 3 0 1) ;; 2
     #(3 2 1 0) ;; 3
     ))
(define (xor2 x y)
  (vector-ref (vector-ref xortbl2x2 x) y))
(define (xor4 x y)
  (let ((x0 (modulo x 4))
        (x1 (quotient x 4))
        (y0 (modulo y 4))
        (y1 (quotient y 4)))
    (+ (* (xor2 x1 y1) 4)
       (xor2 x0 y0))))
(define (xor8 x y)
  (let ((x0 (modulo x 16))
        (x1 (quotient x 16))
        (y0 (modulo y 16))
        (y1 (quotient y 16)))
    (+ (* (xor4 x1 y1) 16)
       (xor4 x0 y0))))
(define (xor16 x y)
  (let ((x0 (modulo x 256))
        (x1 (quotient x 256))
        (y0 (modulo y 256))
        (y1 (quotient y 256)))
    (+ (* (xor8 x1 y1) 256)
       (xor8 x0 y0))))
(define (xor32 x y)
  (let ((x0 (modulo x 65536))
        (x1 (quotient x 65536))
        (y0 (modulo y 65536))
        (y1 (quotient y 65536)))
    (+ (* (xor16 x1 y1) 65536)
       (xor16 x0 y0))))

(define (make-rng max) ;; Xorshift32
  (define y 2463534242)
  (lambda ()
    (set! y (xor32 y (u<<13 y)))
    (set! y (xor32 y (u>>17 y)))
    (set! y (xor32 y (u<<5 y)))
    (modulo y max)))

(define global-rng (make-rng 2147483648))

(define (shuffle-vector! vec)
  (let ((len (vector-length vec)))
   (let loop ((idx (- len 1)))
    (unless (= idx 0)
      (let* ((r (modulo (global-rng) (+ idx 1)))
             (c (vector-ref vec idx)))
        (vector-set! vec idx (vector-ref vec r))
        (vector-set! vec r c)
        (loop (- idx 1)))))))

;; RNG
(let ((rng (make-rng 97)))
 (let loop ((idx 0)
            (cur '()))
   (cond
     ((= idx 20)
      (check-equal (reverse cur)
                   '(28 56 29 70 42 26 29
                     96 79 14 44 5 77 17
                     60 14 14 47 60 82)))
     (else
       (loop (+ idx 1) (cons (rng) cur))))))

;; bits32
(define iota32 (list->vector 
                 (let loop ((idx 0) (cur '()))
                  (if (= idx 32)
                    cur
                    (loop (+ idx 1) (cons idx cur)))))) 

(let loop ((cnt 0))
 (unless (= cnt 20)
   (shuffle-vector! iota32)
   ;(display iota32) (newline)
   (let ((cmvec -1))
    (vector-for-each
      (lambda (idx)
        (let ((next (bcl-s32 cmvec idx)))
         (check-equal (bitset-s32? cmvec idx) #t)
         (check-equal (bitset-s32? next idx) #f)
         (when (= next cmvec)
           (display (list cmvec idx)) (newline))
         (set! cmvec next)
         ))
      iota32)
    (check-equal cmvec 0))
   (loop (+ cnt 1)))) 

(let loop ((cnt 0))
 (unless (= cnt 20)
   (shuffle-vector! iota32)
   ;(display iota32) (newline)
   (let ((cmvec 0))
    (vector-for-each
      (lambda (idx)
        (let ((next (bts-s32 cmvec idx)))
         (check-equal (bitset-s32? cmvec idx) #f)
         (check-equal (bitset-s32? next idx) #t)
         (when (= next cmvec)
           (display (list cmvec idx)) (newline))
         (set! cmvec next)))
      iota32)
    (check-equal cmvec -1))
   (loop (+ cnt 1)))) 

(let loop ((cnt 0))
 (unless (= cnt 20)
   (shuffle-vector! iota32)
   (vector-for-each
     (lambda (idx)
       (check-equal (bsr-s32 (bts-s32 0 idx)) idx))
     iota32)
   (loop (+ cnt 1))))

;; bitvector
(let ((iota4096 (list->vector 
               (let loop ((idx 0) (cur '()))
                (if (= idx 4096)
                  cur
                  (loop (+ idx 1) (cons idx cur)))))))
  (let loop ((cnt 0))
    (unless (= cnt 5)
      (shuffle-vector! iota4096)
      (let* ((bitvec (make-bitvector 4096))
             (clear (bitvec 'CLEAR))
             (set (bitvec 'SET))
             (unset (bitvec 'UNSET))
             (check (bitvec 'CHECK)))
        (clear)
        (vector-for-each (lambda (idx)
                           (check-equal (check idx) #f)
                           (set idx)
                           (check-equal (check idx) #t)
                           (unset idx)
                           (check-equal (check idx) #f))
                         iota4096))
      (loop (+ cnt 1))))) 

;; allocator
(let loop ((cnt 0))
 (define (random-vector count max)
   (let ((vec (make-vector count)))
    (let itr ((idx 0))
      (unless (= idx (vector-length vec))
        (vector-set! vec idx (modulo (global-rng) max))
        (itr (+ idx 1))))
    vec))
 (define maxsize (* 1024 1024 4))
 (define (storage)
   (define vec (make-vector maxsize 0))
   (define (size) maxsize)
   (define (iref pos) (vector-ref vec pos))
   (define (iset pos v) (vector-set! vec pos v))
   (define (query sym)
     (case sym
       ((SIZE) size)
       ((REF) iref)
       ((SET!) iset)
       (else (error "Unknown query" sym))))
   query)
 (define my-storage (storage))
 (unless (= cnt 2)
   (let* ((setA (random-vector 70 900))
          (posA (make-vector 70 #f))
          (setB (random-vector 7000 100))
          (posB (make-vector 7000 #f))
          (setC (random-vector 700 100))
          (posC (make-vector 700 #f))
          (heap (fixnum-allocator my-storage)))
     (let ((alloc (heap 'ALLOC))
           (free (heap 'FREE))
           (init (heap 'INIT))
           (dump (heap 'DUMP-REGIONS))
           (iset (my-storage 'SET!))
           (iref (my-storage 'REF)))
       (define (do-alloc in out)
         (let ((cnt (vector-length in)))
          (let itr ((idx 0))
           (unless (= idx cnt)
             (let ((w (* 8 (+ 1 (vector-ref in idx)))))
              (let ((rnd (make-vector (- w 2) (begin (global-rng) #t)))
                    (n (alloc w)))
                ;(display (list 'alloc w '=> n)) (newline)
               (let setloop ((i 0))
                (unless (= i (- w 2))
                  (iset (+ n i 2) (vector-ref rnd i))
                  (setloop (+ i 1))))
               (vector-set! out idx (cons n rnd))))
             (itr (+ idx 1))))))
       (define (do-free pos)
         (let ((cnt (vector-length pos)))
          (let itr ((idx 0))
           (unless (= idx cnt)
             (let ((n (car (vector-ref pos idx)))
                   (v (cdr (vector-ref pos idx))))
               (let cmploop ((i 0))
                (unless (= i (vector-length v))
                  (unless (equal? (iref (+ n i 2)) (vector-ref v i))
                    (error "Data error" n i))
                  (cmploop (+ i 1))))
               ;(display (list 'free n)) (newline)
               (free n))
             (itr (+ idx 1))))))
       (init)
       (do-alloc setA posA)
       (do-alloc setB posB)
       (shuffle-vector! posA)
       (do-free posA)
       (do-alloc setC posC)
       (shuffle-vector! posC)
       (do-free posC)
       (shuffle-vector! posB)
       (do-free posB)
       (let ((d (dump)))
        (check-equal (caddr (car d)) #f) ;; Free block
        (check-equal (length d) 1))))
   (loop (+ cnt 1))))

(check-finish)
